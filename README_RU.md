[![GoDoc](https://godoc.org/github.com/claygod/coffer?status.svg)](https://godoc.org/github.com/claygod/coffer) [![Travis CI](https://travis-ci.org/claygod/coffer.svg?branch=master)](https://travis-ci.org/claygod/coffer) [![Go Report Card](https://goreportcard.com/badge/github.com/claygod/coffer)](https://goreportcard.com/report/github.com/claygod/coffer) [![codecov](https://codecov.io/gh/claygod/coffer/branch/master/graph/badge.svg)](https://codecov.io/gh/claygod/coffer)

# Coffer

Простая key-value ACID* база данных.

*is a set of properties of database transactions intended to guarantee validity even in the event of errors, power failures, etc.

## Конфигурирование

Фактически, достаточно указать путь к директории базы данных, и все параметры конфигурации установятся на дефолтные:

	cof, err, wrn := Db(dirPath).Create()

Однако каждый из параметров можно сконфигурировать:
	Db(dirPath).
	BatchSize(batchSize).
	LimitRecordsPerLogfile(limitRecordsPerLogfile).
	FollowPause(100*time.Second).
	LogsByCheckpoint(1000).
	AllowStartupErrLoadLogs(true).
	MaxKeyLength(maxKeyLength).
	MaxValueLength(maxValueLength).
	MaxRecsPerOperation(1000000).
	RemoveUnlessLogs(true).
	LimitMemory(100 * 1000000).
	LimitDisk(1000 * 1000000).
	MaxRecsPerOperation(1000).
	Handler("handler1", &handler1).
	Handler("handler2", &handler2).
	Handlers(map[string]*handler).
	Create()

### Старт

При старте последним по номеру должен быть чекпойнт. Если это не так, то значит, остановка была некорректной.
Тогда грузится последний имеющийся чекпоинт и все логи после него до тех пор, пока это возможно. На битом логе
или последнем логе скачиваем, пока получается, и на этом загрузку заканчиваем. БД создаёт новый чекпоинт,
и после этого возможно продолжение исполнение кода.

### Follow

После того, как БД будет запущена, она пишет все операции в журнал. В результате лог может сильно разрастись.
Если в конце концов при окончании работы приложения БД будет корректно остановлена,
то появится новый чекпойнт, и при последующем старте именно из него и будут взяты данные.
Однако, остановка может оказаться некорректной, и новый чекпойнт создан не будет.

В этом случае при новом старте БД будет вынуждена загрузить старый чекпоинт, и провести заново все операции,
которые были совершены и записаны в журнал. Это может оказаться весьма значительным по времени, и в конечном
итоге база будет грузиться значительно дольше, что не всегда приемлемо для приложений.

Именно поэтому в БД существует механизм фолловера, который методично перебирает логи в процессе работы БД
и периодически создаёт чекпойнты, которые значительно ближе по состоянию к текущему моменту.
Также за фолловером можно закрепить функцию чистки старых логов и чекпойнтов, чтобы освобождать
место на жёстком диске.

## TODO

- [x] журнал при старте должен начинать новый лог
- [x] разобраться с именами чекпоинтов и логов (логика нумерации)
- [x] запуск и работа фолловера
- [x] чистка ненужных логов фолловером
- [ ] предусмотреть возможность не удалять старые логи
- [ ] загрузка с битых файлов (чтобы останавливалась загрузка, но работа продолжалась
- [x] циклическая загрузка чекпойнтов, пока они не кончатся (при ошибках)
- [x] возврат не ошибок, а отчётов о проделанной работе
- [x] добавить DeleteOptional,  в том числе и в Operations
- [x] тест Count
- [x] тест Write
- [x] тест Read
- [x] тест Delete
- [x] тест Transaction
- [x] тест на загрузку с битым логом (последним, остальные в порядке)
- [x] тест на загрузку с битым чекпоинтом
- [x] тест на загрузку с битым логом и идущим за ним ещё одним логом
- [x] тест на использование транзакции
- [x] для удобства тестирования сделать WriteUnsafe
- [ ] для чего нужен WriteUnsafeRecord в Checkpoint ? (для записи при старте?) альтернатива WriteListUnsafe (быстрее)
- [x] бенчмарк записи конкурентной и не конкурентной
- [ ] бенчмарк чтения конкурентного и не конкурентного
- [ ] бенчмарк записии и чтения в конкурентном режиме
- [x] бенчмарк конкурентных транзакций в параллельном режиме
- [ ] при загрузке - при поломанных файлах возвращаться может wrn, а не err
- [x] разобраться с журналом и батчером, почему при быстрой записи records попадают в следующий лог
- [ ] перехват паник во всех пакетах
- [ ] при транзакциях можно некоторые записи из участвующих удалять (!надобность под вопросом!)
- [x] тестирование вспомогательных хэлперов
- [x] при создании БД сразу добавлять список хэндлеров, т.к. и загрузка из логов тоже происходит сразу
- [x] добавить удобный конфигуратор при создании бд
- [ ] комментарии перевести на английский язык
- [ ] очистить код от старых артефактов
- [ ] завести каталог для документации
- [ ] прогнать линтер и устранить все некорректности в коде
- [ ] добавить Usage текст в readme
- [ ] описание кодов ошибок
- [ ] все импортируемые пакеты перенести в дистрибутив

## Benchmark

BenchmarkCofferWriteParallel32LowConcurent-4			100000		 14587 ns/op
BenchmarkCofferTransactionSequence-4					  2000		997035 ns/op
BenchmarkCofferTransactionPar32NotConcurent-4			100000		 12494 ns/op
BenchmarkCofferTransactionPar32HalfConcurent-4		100000		 14542 ns/op

### Copyright © 2019 Eduard Sesigin. All rights reserved. Contacts: <claygod@yandex.ru>
