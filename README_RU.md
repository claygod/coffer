[![GoDoc](https://godoc.org/github.com/claygod/coffer?status.svg)](https://godoc.org/github.com/claygod/coffer) [![Travis CI](https://travis-ci.org/claygod/coffer.svg?branch=master)](https://travis-ci.org/claygod/coffer) [![Go Report Card](https://goreportcard.com/badge/github.com/claygod/coffer)](https://goreportcard.com/report/github.com/claygod/coffer) [![codecov](https://codecov.io/gh/claygod/coffer/branch/master/graph/badge.svg)](https://codecov.io/gh/claygod/coffer)

# Coffer

Простая key-value ACID* база данных.

*is a set of properties of database transactions intended to guarantee validity even in the event of errors, power failures, etc.

## API

Запущенная БД после выполнения операции возвращает отчёт с результатами:
- кодом
- ошибкой (коды ошибок хранятся здесь: `github.com/claygod/coffer/reports`)
- данными
- другими подробностями
Ознакомиться со структурами ответов можно здесь: `github.com/claygod/coffer/reports`

### Methods
* Start
* Stop
* StopHard
* Save
* Write
* WriteList
* WriteListUnsafe
* Read
* ReadList
* ReadListUnsafe
* Delete
* DeleteListStrict
* DeleteListOptional
* Transaction
* Count
* RecordsList
* RecordsListUnsafe
* RecordsListWithPrefix
* RecordsListWithSuffix

#### Start

Запустить БД. Большинство методов работает только если БД запущена.
Пи запуске включается `Follow` интерактор, который следит за актуальностью текущего чекпоинта.

#### Stop

Остановить БД. Если вы хотите в своём приложении периодически останавливать и запускать БД,
возможно, после остановки вы захотите создать новый клиент.


#### Write

Записать в БД новую запись, указав ключ и значение.
Их длина должна удовлетворять требованиям, указанным в конфигурации.

#### WriteList

Записать в БД несколько записей, указам в агрументах соответствующую `map`.
Важно: этот аргумент ссылочный, его нельзя изменять!

#### WriteListUnsafe

Записать в БД несколько записей, указам в агрументах соответствующую `map`.
Этот метод существует для того, чтобы перед запуском БД немного быстрее её наполнять.
Метод не подразумевает параллельного использования.

#### Read

Прочитать одну запись из БД. В полученом `report` будет код результата, и если он положительный,
то и значение в соответствующем поле.

#### ReadList

Прочитать несколько записей. Ограничение на максимальное количество читаемых записей есть в конфигурации.
Помимо найденных записей, возвращается список не найденных записей.

#### ReadListUnsafe

Прочитать несколько записей. Метод может быть вызван при остановленной (или не запущенной) БД.
Метод не подразумевает параллельного использования.

#### Delete

Удалить одну запись.

#### DeleteListStrict

Удалить несколько записей, но только если все они есть в БД. Если хотя бы одной записи нет,
то ни одна запись удалена не будет.

#### DeleteListOptional

Удалить несколько записей. Удалены будут все записи из списка, которые будут найдены в БД.

#### Transaction

Выполнить транзакцию. Транзакция должна быть занесена в БД на этапе создания и конфигурирования БД.
Ответственность за консистентность функционала обработчиков транзакций между разными запусками БД
лежит на пользователе БД. Транзакция возвращает новые значения, сохранённые в БД.

#### Count
#### RecordsList
#### RecordsListUnsafe
#### RecordsListWithPrefix
#### RecordsListWithSuffix


## Конфигурирование

Фактически, достаточно указать путь к директории базы данных, и все параметры конфигурации установятся на дефолтные:

	cof, err, wrn := Db(dirPath) . Create()

Дефолтные значения можно увидеть в файле `/config.go` .
Однако каждый из параметров можно сконфигурировать:
	Db(dirPath).
	BatchSize(batchSize).
	LimitRecordsPerLogfile(limitRecordsPerLogfile).
	FollowPause(100*time.Second).
	LogsByCheckpoint(1000).
	AllowStartupErrLoadLogs(true).
	MaxKeyLength(maxKeyLength).
	MaxValueLength(maxValueLength).
	MaxRecsPerOperation(1000000).
	RemoveUnlessLogs(true).
	LimitMemory(100 * 1000000).
	LimitDisk(1000 * 1000000).
	MaxRecsPerOperation(1000).
	Handler("handler1", &handler1).
	Handler("handler2", &handler2).
	Handlers(map[string]*handler).
	Create()
	
### Db(dirPath)
### BatchSize(batchSize)
### LimitRecordsPerLogfile(limitRecordsPerLogfile)
### FollowPause(100*time.Second)
### LogsByCheckpoint(1000)
### AllowStartupErrLoadLogs(true)
### MaxKeyLength(maxKeyLength)
### MaxValueLength(maxValueLength)
### MaxRecsPerOperation(1000000)
### RemoveUnlessLogs(true)
### LimitMemory(100 * 1000000)
### LimitDisk(1000 * 1000000)
### MaxRecsPerOperation(1000)
### Handler("handler1", &handler1)
### Handler("handler2", &handler2)
### Handlers(map[string]*handler)
### Create()
	
## Quick start

### Старт

При старте последним по номеру должен быть чекпойнт. Если это не так, то значит, остановка была некорректной.
Тогда грузится последний имеющийся чекпоинт и все логи после него до тех пор, пока это возможно. На битом логе
или последнем логе скачиваем, пока получается, и на этом загрузку заканчиваем. БД создаёт новый чекпоинт,
и после этого возможно продолжение исполнение кода.

### Follow

После того, как БД будет запущена, она пишет все операции в журнал. В результате лог может сильно разрастись.
Если в конце концов при окончании работы приложения БД будет корректно остановлена,
то появится новый чекпойнт, и при последующем старте именно из него и будут взяты данные.
Однако, остановка может оказаться некорректной, и новый чекпойнт создан не будет.

В этом случае при новом старте БД будет вынуждена загрузить старый чекпоинт, и провести заново все операции,
которые были совершены и записаны в журнал. Это может оказаться весьма значительным по времени, и в конечном
итоге база будет грузиться гораздо дольше, что не всегда приемлемо для приложений.

Именно поэтому в БД существует механизм фолловера, который методично перебирает логи в процессе работы БД
и периодически создаёт чекпойнты, которые значительно ближе по состоянию к текущему моменту.
Также за фолловером закреплена функция чистки старых логов и чекпойнтов, чтобы освобождать
место на жёстком диске.

## Хранение данных

Ваши данные хранятся в виде файлов в том каталоге, который вы указали при создании базы. 
Файлы с расширением `log` содержат описание выполненных операций.
Файлы с расширением `checkpoint` содержат снимки состояния БД на определённый момент.
Файлы с расширением `check` содержат неполный снимок состояния БД.
Используя параметр конфигурации `RemoveUnlessLogs` , вы може приказать БД
старые и ненужные файлы удалять, чтобы сберечь дисковое пространство.

Если база данных остановлена в штатном режиме, то последним файлом, записанным на диск,
будет файл `checkpoint`, а его номер будет максимальным.
Если база данных остановлена некорректно, то скорей всего максимальный номер будет у файла
с расширением `log` или `check`.

Внимание! до тех пор, пока БД полностью не остановлена, запрещено с файлами базы данных
проводить какие-либо операции.

Если вы хотите скопировать куда-либо базу, то необходимо копировать всё содержимое директории.
Если вы хотите при копировании скопировать минимум файлов, то необходимо скопировать файл
с расширением `checkpoint` , имеющий максимальный номер, и все файлы с расширением `log` ,
которые имеют номер, больший чем у скопированного файла `checkpoint`.

### Загрузка данных после некорректного отключения

Если работа приложения, использующего БД завершена некорректно, то при следующей загрузке БД
постарается найти последний корректный снимок состояния `checkpoint`. Найдя этот файл, БД загрузит его,
после чего загрузит все `log` файлы с большими номерами. Мы ожидаем, что последний `log` файл может
быть не до конца заполненным, так как во время записи работа могла быть прервана. Поэтому загрузка
с испорченного файла будет выполнена до испорченного (недозаписанного) участка, после чего
загрузка БД считается завершенной. По кончании загрузки БД создаёт новый `checkpoint`.
Если сбои системы происходят во время старта (загрузки) БД, возможны ошибки и нарушение
консистентности данных.

## Коды ошибок

Коды ошибок хранятся здесь: "github.com/claygod/coffer/reports"

## Benchmark

- BenchmarkCofferWriteParallel32LowConcurent-4		100000	12933 ns/op
- BenchmarkCofferTransactionSequence-4			2000		227928 ns/op
- BenchmarkCofferTransactionPar32NotConcurent-4	100000	4132 ns/op
- BenchmarkCofferTransactionPar32HalfConcurent-4	100000	4199 ns/op

## Dependencies

- github.com/shirou/gopsutil/disk
- github.com/shirou/gopsutil/mem
- github.com/sirupsen/logrus

## TODO

- [x] журнал при старте должен начинать новый лог
- [x] разобраться с именами чекпоинтов и логов (логика нумерации)
- [x] запуск и работа фолловера
- [x] чистка ненужных логов фолловером
- [ ] предусмотреть возможность не удалять старые логи, добавить тест!
- [x] загрузка с битых файлов, чтобы останавливалась загрузка, но работа продолжалась (AllowStartupErrLoadLogs)
- [x] циклическая загрузка чекпойнтов, пока они не кончатся (при ошибках)
- [x] возврат не ошибок, а отчётов о проделанной работе
- [x] добавить DeleteOptional,  в том числе и в Operations
- [x] тест Count
- [x] тест Write
- [x] тест Read
- [x] тест Delete
- [x] тест Transaction
- [x] тест RecordsList
- [x] тест RecordsListUnsafe
- [x] тест RecordsListWithPrefix
- [x] тест RecordsListWithSuffix
- [x] тест ReadListUnsafe
- [x] тест на загрузку с битым логом (последним, остальные в порядке)
- [x] тест на загрузку с битым чекпоинтом
- [x] тест на загрузку с битым логом и идущим за ним ещё одним логом
- [x] тест на использование транзакции
- [x] для удобства тестирования сделать WriteUnsafe
- [x] ~~для чего нужен WriteUnsafeRecord в Checkpoint ? (для записи при старте?)~~ альтернатива WriteListUnsafe (быстрее)
- [x] бенчмарк записи конкурентной и не конкурентной
- [x] бенчмарк чтения конкурентного
- [ ] бенчмарк записии и чтения в конкурентном режиме
- [x] бенчмарк конкурентных транзакций в параллельном режиме
- [ ] при загрузке - при поломанных файлах возвращаться может wrn, а не err
- [x] разобраться с журналом и батчером, почему при быстрой записи records попадают в следующий лог
- [x] перехват паник в корне приложения и на уровне usecases
- [ ] ~~при транзакциях можно некоторые записи из участвующих удалять (!надобность под вопросом!)~~
- [x] тестирование вспомогательных хэлперов
- [x] при создании БД сразу добавлять список хэндлеров, т.к. и загрузка из логов тоже происходит сразу
- [x] добавить удобный конфигуратор при создании бд
- [ ] комментарии перевести на английский язык
- [ ] очистить код от старых артефактов
- [ ] завести каталог для документации
- [x] завести каталог для примеров
- [x] сделать простой пример с записью, транзакцией и чтением
- [x] сделать пример с финансовыми транзакциями
- [ ] пример обработки ошибок
- [ ] прогнать линтер и устранить все некорректности в коде
- [ ] добавить Usage/Quick start текст в readme
- [ ] описание кодов ошибок
- [ ] описание конфигурирования
- [x] в описании указать сторонние пакеты (как зависимости)
- [x] репортам добавить методы проверки на все ошибки в духе IsErrBlahBlahBlah
- [x] все импортируемые пакеты перенести в дистрибутив
- [x] перевести использование WriteUnsafeRecord на WriteListUnsafe
- [x] добавитьReadListUnsafe для возможности чтения при остановленной базе
- [x] добавить RecordsListUnsafe, который может работать и при остановленной и при работающей БД
- [x] получение списка ключей с условием по префиксу RecordsListWithPrefix
- [x] получение списка ключей с условием по суффиксу RecordsListWithSuffix
- [x] убрать метод Save
- [x] при транзакции возвращать в отчёте новые значения
- [x] в тестах проверить возвращаемое значение

### Copyright © 2019 Eduard Sesigin. All rights reserved. Contacts: <claygod@yandex.ru>
